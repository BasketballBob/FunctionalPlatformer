<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_playerNeutral</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Basic Variables
image_speed = 0;
image_xscale = -1;
depth = 0;

//Player Variables
moveSpeed = 5; //5
hSpeed = 0;
hModifier = 0;
moveRate = .5;
moveCap = 5;
frict = .5;
vSpeed = 0;
vModifier = 0;
grav = 1;
gravCap = 15;
jumpSpeed = 14; //14
jumpPadSpeed = 20;
jumpAlarm = 0;
jumpDelay = 2; 
cutscene = false;
onHPlatform = false
coyoteTime = 3;
coyoteAlarm = 0;
//extendedJumpAlarm = 0;
//extendedJumpTime = 10;

dead = false;
deathTime = 60;
deathJump = 10;
deathSpin = 14;

//Initialize Camera
script_execute(scr_cameraConstruct);
//cdv = 0; //1
cameraSpeed = 2; //1
cameraOffSet = 320; //2
cx = 0;
cy = 0; //y-view_hview[0]/1.4 (This operation is set under the checkpoint manager)
cdx = x;
cdy = y; //y
playerLocked = false;
camXCap = 80;
camXDist = camXCap;
camXDistEnabled = true; //false
camXRate = 2;
camXSpeedRatio = .035; //.035
lastXScale = -1;

//Special Camera Variables
cameraTimeline = 0;
camOgX = view_xview[0];
camOgY = view_yview[0];
//Elevator
elShakeSpeed = 1;
elShakeRate = 1;
elShakeDelay = 5;
elShakeAlarm = elShakeDelay;
elDropDist = 50; //50
elDropTime = 50; //50
elBackSpeed = 6;
elBackRate = 6;
elBackAlarm = 0;
elStartYOffSet = -40;

//UI Variables
lastDepth = 0;

//Conversation Variables
conversation = false;
convAlpha = 1; //.55;
convScale = 1;
convClose = false;
convIcon = false;
convPhase = 0;
convSprite = spr_basketball;
convImg = 0;
convImgSpeed = .25;
convImgAlarm = 0;
prevConvPhase = -1;
prevBigConvPhase = -1;
prevConvInst = -1;
convInputAlarm = 0;
convInputTime = 20;
convInputScale = .25;
goodByeAlarm = 0;
goodByeTime = convInputTime;
goodByeActive = false;

//Checkpoint Manager
if(global.checkPointRoom == room)
{
    x = global.checkPointId.x;
    y = global.checkPointId.y+sprite_height/2;
}
cy = y-view_hview[0]/1.4;//(obj_followingYolk camera edgecase)

//Generate Necessary GUI
if(instance_exists(obj_water))
{   
    //instance_create(x,y,obj_verticalWaterGUI);
}

//Player Input
up = keyboard_check(ord('W')) || keyboard_check(vk_up) || keyboard_check(vk_space);
down = keyboard_check(ord('S')) || keyboard_check(vk_down);
right = keyboard_check(ord('D')) || keyboard_check(vk_right);
left = keyboard_check(ord('A')) || keyboard_check(vk_left);
use = keyboard_check_pressed(ord('Z'));

//Initialize Global Vars
globalVarsInitialized = false;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Developer Commands
if(keyboard_check_pressed(ord('R')))
{
    room_restart();
}
if(keyboard_check_pressed(ord('F')))
{
    window_set_fullscreen(!window_get_fullscreen());
}

if(keyboard_check_pressed(ord('O')) &amp;&amp; room_exists(room_next(room)))
{
    room_goto_next();
}
else if(keyboard_check_pressed(ord('I')) &amp;&amp; room_exists(room_previous(room)))
{
    room_goto_previous();
}

if(keyboard_check_pressed(ord('K')))
{
    camXDist = 0;
}

//Initialize Global Vars 
if(!globalVarsInitialized)
{
    global.prevRoom = room;
    globalVarsInitialized = true;
}

//Set Texture Drawing
texture_set_interpolation(false);

//Freeze Player If In Cutscene
if(cutscene) //instance_exists(obj_fadeInElevator) || 
{
    //image_speed = 0;
    //exit;
}

//Player Input
if(!cutscene &amp;&amp; !conversation){
    up = keyboard_check(ord('W')) || keyboard_check(vk_up) || keyboard_check(vk_space);
    down = keyboard_check(ord('S')) || keyboard_check(vk_down);
    right = keyboard_check(ord('D')) || keyboard_check(vk_right);
    left = keyboard_check(ord('A')) || keyboard_check(vk_left);
    use = keyboard_check_pressed(ord('Z'));
}
else{
    up = false;
    down = false;
    right = false;
    left = false;
    use = false;
}

//Conversation Input
if(conversation)
{
    use = keyboard_check_pressed(ord('Z'));
}

//Camera Movement
script_execute(scr_cameraControl);

//Reset Collision Sprite
mask_index = spr_basicCollision;

//
if(keyboard_check_pressed(ord('T')))
{
    room_goto(rm_tutorial_intro4);
}

//Death Animation
if(dead)
{
    //Fall
    y += vSpeed;
    vSpeed += grav;
    
    //Spin
    image_angle += deathSpin;
    
    //Pop Out
    depth = -3.9;
    
    //Skip Everything Else
    exit;
}

//Death Timer
/*if(dead &amp;&amp; deathTime &gt; 0)
{
    deathTime -= 1;
    exit;
}
else if(dead)
{
    room_restart();
    exit;
}*/

//Gravity
if(!place_meeting(x,y+1,obj_wall) &amp;&amp; vSpeed &lt; gravCap)
{
    vSpeed += grav;
}

//Coyote Time
if(place_meeting(x,y+1,obj_wall) &amp;&amp; vSpeed == 0)
{
    coyoteAlarm = coyoteTime;
}
else if(coyoteAlarm &gt; 0)
{
    coyoteAlarm -= 1;
}

//Jumppad 
if(place_meeting(x,y+1,obj_jumpPad))
{
    vSpeed = -jumpPadSpeed;
    coyoteAlarm = 0;
}

//Jump Delay
else if(jumpAlarm &gt; 0 &amp;&amp; place_meeting(x,y+1,obj_wall))
{
    jumpAlarm -= 1;
}


//Jump
else if(up &amp;&amp; place_meeting(x,y+1,obj_wall) &amp;&amp; vSpeed == 0 &amp;&amp; playerLocked ||
up &amp;&amp; coyoteAlarm &gt; 0 &amp;&amp; playerLocked) //&amp;&amp; extendedJumpAlarm == 0) //JumpAlarm added
{
    vSpeed = -jumpSpeed;
    jumpAlarm = jumpDelay;
    //extendedJumpAlarm = extendedJumpTime;
    coyoteAlarm = 0;
    //audio_play_sound(snd_jumpingTest,1,0);
}

//Extended Jump
/*else if(up &amp;&amp; extendedJumpAlarm &gt; 0)
{
    vSpeed = -jumpSpeed;
    extendedJumpAlarm -= 1;
}
else extendedJumpAlarm = 0;*/

//Vertical Platform
vModifier = 0;
if(place_meeting(x,y+1,obj_verticalMovingPlatform))
{
    //vModifier = instance_place(x,y+1,obj_verticalMovingPlatform).vSpeed;
}

//Extended Jump
/*else if(up &amp;&amp; !place_meeting(x,y+1,obj_wall) &amp;&amp; holdAlarm &lt; holdCap)
{
    vSpeed = -jumpSpeed;
    holdAlarm += 1;
}
//End Extended Jump
else if(!place_meeting(x,y+1,obj_wall))
{
    holdAlarm = holdCap;
}
//Reset Extended Jump 
if(place_meeting(x,y+1,obj_wall))
{
    holdAlarm = 0;
}*/

//Door Interaction
if(place_meeting(x,y,obj_elevatorDoor) &amp;&amp; room_exists(room_next(room)))
{   
    //room_goto_next();
    //instance_create(x,y,obj_fadeInElevator);
}

//VSpeed Manager
if(vSpeed+vModifier != 0)
{
    if(!place_meeting(x,y+vSpeed+vModifier,obj_wall))
    {
        y += vSpeed+vModifier;
    }
    else if(!place_meeting(x,y+sign(vSpeed+vModifier),obj_wall))
    {
        do
        {
            y += sign(vSpeed+vModifier);
        }
        until place_meeting(x,y+sign(vSpeed+vModifier),obj_wall);
    }
    
    if(place_meeting(x,y+sign(vSpeed+vModifier),obj_wall))
    {
        //Play Test Sound
        if(sign(vSpeed) = 1)
        {
            //audio_play_sound(snd_landingTest,1,0);
        }
        //extendedJumpAlarm = 0;
        vSpeed = 0;
    }
}

//Horizontal Movement 2
//Player Input
if(right &amp;&amp; !left)
{
    //Edgecase for sliding
    if(hSpeed &lt; 0 &amp;&amp; place_meeting(x,y+1,obj_wall))
    {
        hSpeed = 0;
    }        

    image_xscale = -1;
    if(hSpeed+moveRate &lt; moveCap){
        hSpeed += moveRate;
    }
    else{
        hSpeed = moveCap;
    }
}
else if(left &amp;&amp; !right)
{
    //Edgecase for sliding
    if(hSpeed &gt; 0 &amp;&amp; place_meeting(x,y+1,obj_wall))
    {
        hSpeed = 0;
    }

    image_xscale = 1;
    if(hSpeed-moveRate &gt; -moveCap){
        hSpeed -= moveRate;
    }
    else{
        hSpeed = -moveCap;
    }
}

//Friction
else if(hSpeed != 0 &amp;&amp; !place_meeting(x,y+1,obj_wall))// &amp;&amp; place_meeting(x,y+1,obj_wall))
{
    hSpeed -= frict*sign(hSpeed);
}
else if(hSpeed != 0 &amp;&amp; place_meeting(x,y+1,obj_wall))
{   
    hSpeed = 0;
}

//Horizontal Speed Modifiers
hModifier = 0;
if(place_meeting(x,y+1,obj_movingPlatform))
{
    hModifier += instance_place(x,y+1,obj_movingPlatform).hSpeed;
    onHPlatform = true;
}
else if(place_meeting(x,y+1,obj_ridingPlatform))
{
    hModifier += instance_place(x,y+1,obj_ridingPlatform).hSpeed;
    onHPlatform = true;
}
else
{
    //Edgecase Variable for Animation Glitch
    onHPlatform = false;
}

//Horizontal Manager
if(hSpeed+hModifier != 0)
{
    if(!place_meeting(x+round(hSpeed+hModifier),y,obj_wall))
    {
        x += round(hSpeed+hModifier);
    }
    else if(!place_meeting(x+sign(hSpeed+hModifier),y,obj_wall))
    {   
        do
        {
            x += sign(hSpeed+hModifier);
        }
        until place_meeting(x+sign(hSpeed+hModifier),y,obj_wall);
    }
    
    //Stop Momentum On Impact
    if(place_meeting(x+sign(hSpeed),y,obj_wall)) //(hSpeed+hModifier)
    {
        hSpeed = 0;
    }
}

//Horizontal Movement Manager

//Horizontal Movement
/*
if(right &amp;&amp; !left)
{
    image_xscale = -1;
    if(!place_meeting(x+moveSpeed,y,obj_wall))
    {
        x += moveSpeed;
    }
    else if(!place_meeting(x+1,y,obj_wall))
    {
        do
        {
            x += 1;
        }
        until place_meeting(x+1,y,obj_wall);
    }
}
else if(left &amp;&amp; !right)
{
    image_xscale = 1;
    if(!place_meeting(x-moveSpeed,y,obj_wall))
    {
        x -= moveSpeed;
    }
    else if(!place_meeting(x-1,y,obj_wall))
    {
        do
        {
            x -= 1;
        }
        until place_meeting(x-1,y,obj_wall);
    }
}  
*/

/*
//Operate Camera Horizontal
if(x &gt; view_wview[0]/2 &amp;&amp; x &lt; room_width-view_wview[0]/2)
{
    view_xview[0] = x-view_wview[0]/2;
}
else
{
    if(x &lt; room_width/2)
    {
        view_xview[0] = 0;
    }
    else
    {
        view_xview[0] = room_width-view_wview[0];
    }
}

//Camera Water Vertical
if(instance_exists(obj_water))
{
    if(obj_water.y-cameraOffSet &lt; room_height-view_hview[0] &amp;&amp; obj_water.y-cameraOffSet &gt; 0)//view_hview[0])
    {
        view_yview[0] = obj_water.y-cameraOffSet;
    }
    else
    {
    
    }
}
*/

//Animation Controller
if(!place_meeting(x,y+1,obj_wall) &amp;&amp; !onHPlatform)
{   
    sprite_index = spr_playerJumping;
    
    //Descending
    if(vSpeed &gt; 0)
    {
        image_index = 0; //0
    }
    //Ascending
    else
    {
        image_index = 1; 
    }
}
else if(x != xprevious &amp;&amp; right &amp;&amp; !left || x != xprevious &amp;&amp; left &amp;&amp; !right)
{
    sprite_index = spr_playerRunning;
    image_speed = .3; //.25
}
else
{
    sprite_index = spr_playerNeutral;
}


//Hit Obstacle/Death Initialization
mask_index = sprite_index;
if(place_meeting(x,y,obj_obstacle)
|| y &gt; room_height+30) // || y &lt; 0)
{
    //Death Variable Initialization
    vSpeed = -deathJump;
    sprite_index = spr_playerJumping;
    dead = true;
    
    //Create Death Transition
    instance_create(x,y,obj_deathScreen);
}

//Conversation Manager
if(instance_exists(obj_shortConversant))
{
    //Check If Conversant Is Close Enough
    defaultVal = sqr(room_width);
    convClose = false;
    convDist = defaultVal;
    convReqDist = 100;
    
    //Check All Conversation Instances
    for(i = 0;i &lt; instance_number(obj_shortConversant);i++)
    {
        tv = instance_find(obj_shortConversant,i);
        
        //Check If Close Enough
        if(abs(x-tv.x) &lt; convReqDist)
        {
            //Check For Closet Conversant
            if(abs(x-tv.x) &lt; convDist)
            {
                convInst = tv;
                convDist = abs(x-tv.x);
                convClose = true;
            }
        }
    }
    
    //Manage Prev Conv Inst
    if(!convClose)
    {
        prevConvInst = -1;
    }
    
    
    //Give Player Opportunity To Engage
    if(convClose)
    {
        //image_xscale = 1.5;
        //convInst.image_xscale += .001;
        
        //Begin Conversation
        if(use &amp;&amp; place_meeting(x,y+1,obj_wall) &amp;&amp; !conversation &amp;&amp; convInst != prevConvInst)
        {
            //convInst.playerContact = true;
            convInst.conversationActive = true;
            convInst.progressText = true;
            prevConvInst = convInst;
            conversation = true;
            
            //Give Player Feedback            
            convInputAlarm = convInputTime;
        }
        
        //Player Conversation Input
        else if(use &amp;&amp; !convInst.textActive &amp;&amp; conversation)
        {
            //Progress Conversation (check obj_shortConversant for more info)
            if(convInst.convPos &lt; array_length_1d(convInst.conversation))
            {
                //image_angle += 10;
                convInst.progressText = true;
            }      
              
            //Exit Conversation
            else
            {
                goodByeAlarm = goodByeTime;
                convInst.conversationActive = false;
                conversation = false;
            }
            
            //Give Player Feedback            
            convInputAlarm = convInputTime;
        }
    }
}

//Reset Collision
mask_index = spr_basicCollision;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draw_text(50,50,coyoteAlarm);
//draw_text(50,50,coyoteAlarm);
//draw_text(50,75,cdx);
//draw_text(50,100,cy);
//draw_text(50,125,cdy);
//draw_text(50,50,vSpeed);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Draw Self
draw_self();


//Manage Conversation Icon   
convPhase = -1;
//(INITITATE)
if(!conversation &amp;&amp; convClose &amp;&amp; prevConvInst != convInst)               
{
    convIcon = true;
    convPhase = 0;
}    
//(GOODBYE)
else if(conversation &amp;&amp; !convInst.textActive &amp;&amp; 
convInst.convPos &gt;= array_length_1d(convInst.conversation))
{
    convIcon = true;
    convPhase = 2;
}
//(PROGRESS)  
else if(conversation &amp;&amp; !convInst.textActive)    
{  
    if(!convInst.textActive)  
    {
        convIcon = true;
        convPhase = 0;
    }    
} 
//(Mid-Conversation)
else if(conversation)                        
{
    convIcon = true;
    convPhase = 1;
}
else convIcon = false;

//Manage Conversation Icon From Normal Conversant
//NOTE: Phase Code Can Be Found Within Normal Conversant
bigConvPhase = -1;
if(instance_exists(obj_conversant))
{
    bigConvInst = instance_nearest(x,y,obj_conversant);
    bigConvPhase = bigConvInst.convPhase;
    convIcon = true;
    
    //Turn Off Icon If Necessary
    if(bigConvPhase == -1) convIcon = false;
}       

//Set Previous Conv Phase
prevConvPhase = convPhase;
prevBigConvPhase = bigConvPhase;
        
//Draw Conversation Indicator
if(convIcon &amp;&amp; !dead || goodByeAlarm &gt; 0)
{
    //Draw Final Goodbye (Edgecase for drawing "bye" after conversation has ended)
    goodByeActive = false;
    if(goodByeAlarm &gt; 0)
    {
        convSprite = spr_conversationIndicator;
        convImg = 1;
        convImgSpeed = 0;
        goodByeActive = true;
        goodByeAlarm -= 1;
    }
    
    //Draw "Z" Sprite
    else if(convPhase == 0 || bigConvPhase == 0)
    {
        convSprite = spr_conversationIndicator;
        convImg = 0;
        convImgSpeed = 0;
    }
    
    //Draw Goodbye Promt
    else if(convPhase == 2 || bigConvPhase == 2)
    {
        convSprite = spr_conversationIndicator;
        convImg = 1;
        convImgSpeed = 0;     
    }
    
    //Draw Ellipses
    else if(convPhase == 1 || bigConvPhase == 1)
    {
        convSprite = spr_conversationIndicator_ellipses;
        convImgSpeed = .25;
    }   
    
    //Control Animation
    if(convImgSpeed &gt; 0)
    {
        if(convImgAlarm &gt; 0)
        {
            convImgAlarm -= 1;
        }
        else
        {
            //Next Frame
            if(convImg+1 &lt; sprite_get_number(convSprite))
            {
                convImg++;
            }
            //Loop Animation
            else
            {
                convImg = 0;
            }
        
            //Reset Alarm
            convImgAlarm = round(60*convImgSpeed);
        }
    }
    
    //Control Input Alarm
    if(convInputAlarm &gt; 0)
    {
        convInputAlarm -= 1;
    }
    convScale = 1+convInputScale*(convInputAlarm/convInputTime);
    
    
    //Draw Goodbye (Animation)
    if(goodByeActive)
    {
        //convScale = (1+convInputScale*2)*(goodByeAlarm/goodByeTime);
        convScale = goodByeAlarm/goodByeTime;
        draw_sprite_ext(convSprite,convImg,x-2,y-20,convScale,convScale,0,c_white,convAlpha);
    }
    //Draw Sprite Normally
    else
    {
        draw_sprite_ext(convSprite,convImg,x-2,y-20,convScale,convScale,0,c_white,convAlpha);
    }
}

//image_blend = c_black;

//display_set_gui_size(view_wport[0], view_hport[0]);

//Draw Marker Gui
/*
if(instance_exists(obj_water))
{
    //Variables
    markOffY = view_yview[0]+40; //40
    markOffX = view_xview[0]+view_wview[0]/2; //view_wview[0]/2
    markAlpha = .6; //.6

    draw_sprite_ext(spr_markerBoard,0,markOffX,markOffY,1,1,0,c_white,markAlpha);
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
