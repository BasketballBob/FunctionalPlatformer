<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_yolkChild</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Basic Variables
depth = 1.1; //0

//Yolk Boss Variables

//Attack Management Vars
currentAttack = -1;
attackRange = 2;
attackInitialized = false;
attackTimer = -1;

//Attack Types
//0 - Rocket Barrage
//1 - Bobbing Chainsaws
//2 - Spike Stomp

//Boss Attack Array
attackPos = 0;
bossAttack[0] = 0;
bossAttack[1] = 1;
bossAttack[2] = 2;


//Boss Character Variables
bossDeployed = false;
prevBossDeployed = bossDeployed;
bossDeployRate = .25;
bossX = 400;
bossY = -300;
bossDX = 400;
bossY1 = -300;
bossY2 = 78; //50
bossHSpeed = 1;
bossHCap = 1;
bossVSpeed = 0;
bossVRate = 1;
bossVCap = 6; //Used For Boss Undeployment 
bossColor = make_color_rgb(200,200,200);

//Arm Deployment Vars
armDeployed = false;
armLaunchLid = false;
armImg = 0;
armSpeed = 0;
armRate = .2; //.25
armAngle = -90; //Should equal armAngle1
armAngle1 = -90;
armAngle2 = 0;
armScale = 1;
armScale1 = .1; //.1
armScale2 = 1;
lidX = -90;
lidY = 117;

//Lever Variables (NOTE: To get intro and function leverArms to line up
//you may need to make adjustments in their draw (sorry messy code))
leverDeployed = false;
prevLeverDeployed = false;
leverHeight = sprite_get_height(spr_lever);
leverDrawHeight = 0;
leverArmHeight = sprite_get_height(spr_leverArm);
leverArmDrawHeight = 0;
leverX = -90; 
leverY = 121;
leverR = 0; //R = Rotation
leverDR = 0;
prevLeverDR = 0;
leverRSpeed = 0;
leverRRate = .25;
leverRAngle = 43;

//Airship Deployment Variables
shipDeployed = true;
shipBobbing = false;
shipVSpeed = 0;
shipVRate = .05; //
shipInitialVSpeed = shipVRate*25;
shipXOffSet1 = 300; //320
shipXOffSet2 = 340;
shipX = 0;
shipY = -100;
shipY1 = -100;
shipY2 = 200;
//tinyBossX = 250; Currently Unused
tinyBossY = 25; //225
gunXOffSet = 30;
gunYOffSet = 30;




</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>

//Switch Attack
if(currentAttack == -1)
{
    //Determine New  Attack
    //currentAttack = irandom_range(0,attackRange-1);
    currentAttack = 4; //2
    
    //Determine New Attack With Array
    /*if(attackPos-1 &lt; array_length_1d(bossAttack))
    {
        currentAttack = bossAttack[attackPos];
        attackPos++;
    }
    else
    {
        currentAttack = -1;
    }*/
    
    //Reset Attack Timer
    attackTimer = 0;
    
    //Reset Attack Initialization
    attackInitialized = false;
}

//Manage Boss Attacks
if(currentAttack != -1)
{
    //Increment Attack Timer
    attackTimer += 1;
    
    //ROCKET BARRAGE
    if(currentAttack == 0)
    {
        //Initialize Attack 
        if(!attackInitialized)
        {
            //Attack Variables
            rocketFiring = true;
            rocketAlarm = 0;
            rocketTime = 40;
            rocketY1 = 270;
            rocketY2 = 320;
            rocketDist = 25; //(Offset From Edge Of Screen) //50
            rocketHRange = 75;
            rocketDirCount = 0;
            rocketDirCap = 3;
            
            //Cease Initialization
            attackInitialized = true;
        }
        
        //Begin Firing Rockets
        if(attackTimer == 20)
        {
            rocketFiring = true;                      
        } 
        //Stop Firing Rockets
        else if(attackTimer == 450)
        {
            rocketFiring = false;
        }
        
        //END ATTACK
        else if(attackTimer == 525)
        {
            currentAttack = -1;
        }
        
        //Rocket Firing (SYSTEM)
        if(rocketFiring)
        {
            //Rocket Firing Alarm
            if(rocketAlarm &gt; 0) rocketAlarm -= 1;
            //Firing Of Rockets
            else
            {
                //Determine Firing Direction
                tvRandom = irandom_range(0,1);
                
                //Fire To The Right
                if(tvRandom == 0 &amp;&amp; rocketDirCount &lt; rocketDirCap || rocketDirCount &lt;= -rocketDirCap)
                {
                    tvObject = instance_create(view_xview[0]+rocketDist+irandom_range(0,rocketHRange),irandom_range(rocketY1,rocketY2),obj_rocketLauncher_boss)
                    tvObject.image_xscale = 1;
                    rocketDirCount++;
                }              
                //Fire To The Left
                else if(tvRandom == 1 &amp;&amp; rocketDirCount &gt; -rocketDirCap || rocketDirCount &gt;= rocketDirCap)
                {
                    tvObject = instance_create(view_xview[0]+view_wview[0]-rocketDist-irandom_range(0,rocketHRange),irandom_range(rocketY1,rocketY2),obj_rocketLauncher_boss)
                    tvObject.image_xscale = -1;
                    rocketDirCount--;
                }
                
                //Reset RocketDirCount
                if(tvObject.image_xscale == 1 &amp;&amp; tvRandom == 1 || tvObject.image_xscale == -1 &amp;&amp; tvRandom == 0)
                {
                    rocketDirCount = 0;
                }
                
                //Reset Firing Alarm
                rocketAlarm = rocketTime;
            } 
        }                         
    }
    
    //VERTICAL CHAINSAW
    if(currentAttack == 1)
    {
        //Initialize Attack
        if(!attackInitialized)
        {
            //Attack Variables
            sawArrayExists = true;
            sawBorder = -40; //80
            sawX1 = 0+sawBorder;
            sawX2 = room_width-sawBorder;
            sawY1 = -40; //-60
            sawY2 = 30; //300 
            sawCount = 7; //9
            
            sawMoveSpeed = 1;
            sawHSpeed = 0; //(One Val For ALL Saws)
            sawHCap = 3;
            sawHRate = .25;
            sawHRateMod = 1;
            sawHRateAlarm = 0;
            sawHRateTime = 10;
            sawHDir = 0;
            sawBobbing = false;
            stopBobbing = false;
            dropSaws = true;
            pullSaws = false;
            sawGrav = .5;
            sawVCap = 5;
            sawOGY = room_height/2;
            
            //Generate Array Of BuzzSaws
            for(i = 0;i &lt; sawCount;i++) 
            {
                sawArray[i] = instance_create(sawX1+i*((sawX2-sawX1)/(sawCount)),sawY1,obj_saw_boss); //sawCount-1 (EDGECASE: saws spawning in eachother)
                sawVSpeedArray[i] = 0; //Starting VSpeed Value
            }
            
            //Cease Initialization
            attackInitialized = true;
        }
                
        
        //Deploy Boss
        if(attackTimer == 20)
        {
            bossDeployed = true;
            bossDX = room_width/2;
        }
        //Deploy Boss Arm/Lever
        else if(attackTimer == 90)
        {
            armDeployed = true;
        }
        else if(attackTimer == 140)
        {
            armLaunchLid = true;
        }
        //Begin Saw Bobbing
        else if(attackTimer == 210)
        {
            sawBobbing = true;
        }
        //Move Saws In Various Directions
        else if(attackTimer == 275) sawHDir = 1;
        else if(attackTimer == 475) sawHDir = -1;
        
        //END ATTACK
        else if(attackTimer == 715)
        {
            //sawBobbing = false;
            stopBobbing = true;
            //pullSaws = true;
            sawHDir = 0;     
        }
        else if(attackTimer == 740)
        {
            pullSaws = true;
            armDeployed = false;
        }
        else if(attackTimer == 850)
        {
            bossDeployed = false;
        }
        else if(attackTimer == 940)
        {
            currentAttack = -1;
            //obj_player.image_xscale = 15;
        }
        
        
        //Begin Bobbing/Horizontal Movement
        /*else if(attackTimer == 150) 
        {
            sawBobbing = true;
            //sawHDir = 1;
            armDeployed = true;
        }
        //TEST ATTACK EVENTS
        else if(attackTimer == 200)
        {
            armLaunchLid = true;
        }
        else if(attackTimer == 300)
        {
            leverDR = -leverRAngle;
        }
        else if(attackTimer == 320)
        {
            sawHDir = 1;
        }
        else if(attackTimer == 575)
        {
            leverDR = leverRAngle;
            sawHDir = -1;
        }
        
        //Turnaround 
        else if(attackTimer == 700)
        {            
            //armDeployed = false;
        }*/                    
        
        //Move Saws Downwards ENTRANCE (SYSTEM)
        if(dropSaws &amp;&amp; !sawBobbing &amp;&amp; sawArrayExists)
        {
            //Move Sawblades
            for(i = 0;i &lt; sawCount;i++)
            {
                //Move Towards Position
                if(sawArray[i].y &lt; sawY2)
                {
                    sawArray[i].y += sawMoveSpeed;
                }
                //Lock At Position
                else
                {
                    sawArray[i].y = sawY2;   
                    dropSaws = false;                 
                }
            }
        }
        //Move Sawblades Upwards EXIT (SYSTEM)
        else if(pullSaws &amp;&amp; !sawBobbing &amp;&amp; sawArrayExists)
        {
            //Move Sawblades
            for(i = 0;i &lt; sawCount;i++)
            {
                //Move Towards Position
                if(sawArray[i].y &gt; sawY1)
                {
                    sawArray[i].y -= sawMoveSpeed;
                }
                //Lock At Position
                else
                {
                    //Delete Saw Array (WILL DELETE ALL SAWS WHEN FIRST SAW IS CALLED TO BE DELETED)
                    for(i = 0;i &lt; sawCount;i++)
                    {
                        instance_destroy(sawArray[i]);
                    }
                    
                    sawArrayExists = false;
                    pullSaws = false;
                    break;                 
                }
            }
        }     
        
        //Manage Sawblade Bobbing (SYSTEM)
        if(sawBobbing &amp;&amp; sawArrayExists)
        {
            for(i = 0;i &lt; sawCount;i++)
            {
                //Gravitate Upwards
                if(sawArray[i].y &gt; sawOGY)
                {
                    sawVSpeedArray[i] -= sawGrav;                   
                }
                //Gravitate Downwards
                else
                {
                    sawVSpeedArray[i] += sawGrav;
                }
                
                //Actually Move Saw Position (vertically)
                sawArray[i].y += sawVSpeedArray[i];       
                
                //Stop Bobbing
                if(stopBobbing)
                {
                    //Stop Once Top Of Screen Is Hit
                    if(sawVSpeedArray[i] == 0 &amp;&amp; sawArray[i].y &lt; room_height/2)
                    {
                        sawBobbing = false;
                        stopBobbing = false;
                    }
                }                                                
            }
         }
         
        //Manage Sawblade Horizontal Movement (SYSTEM)
        if(sawHDir == 1 &amp;&amp; sawArrayExists || sawHDir == -1 &amp;&amp; sawArrayExists || sawHDir = 0 &amp;&amp; sawArrayExists)
        {
            //Determine Saw HRate Modifier (Makes turning around faster)
            if(sign(sawHSpeed) == -sign(sawHDir))
            {
                sawHRateMod = 2;
            }
            else sawHRateMode = 1;
            
            //Manage HRate Alarm
            if(sawHRateAlarm &gt; 0) 
            {
                sawHRateAlarm -= 1;
            }
            //Saw Dir 1
            else if(sawHDir == 1 &amp;&amp; sawHSpeed+sawHRate*sawHRateMod*sawHDir &lt; sawHCap*sawHDir)
            {
                sawHSpeed += sawHRate*sawHRateMod*sawHDir;
                sawHRateAlarm = sawHRateTime;
            }
            else if(sawHDir == 1)
            {
                sawHSpeed = sawHCap*sawHDir;
                sawHRateAlarm = sawHRateTime;
            }
            //Saw Dir -1
            else if(sawHDir == -1 &amp;&amp; sawHSpeed+sawHRate*sawHRateMod*sawHDir &gt; sawHCap*sawHDir)
            {
                sawHSpeed += sawHRate*sawHRateMod*sawHDir;
                sawHRateAlarm = sawHRateTime;
            }
            else if(sawHDir == -1)
            {
                sawHSpeed = sawHCap*sawHDir;
                sawHRateAlarm = sawHRateTime;
            }
            
            //Slow To A Stop
            else if(sawHDir == 0)
            {
                sawHSpeed -= sawHRate*sign(sawHSpeed);
                sawHRateAlarm = sawHRateTime;
            }
            
            //Modify All Saws Accordingly
            for(i = 0;i &lt; sawCount;i++)
            {          
                //Move Saws 
                sawArray[i].x += sawHSpeed;
                  
                //Have Saws Loop Past Boundaries
                if(sawArray[i].x &lt; sawX1)
                {
                    sawArray[i].x = sawX2;
                }
                else if(sawArray[i].x &gt; sawX2)
                {
                    sawArray[i].x = sawX1;
                }
            }                       
            
            //Manage Lever Dir
            if(sawHDir == 1) leverDR = -leverRAngle;
            else if(sawHDir == -1) leverDR = leverRAngle;
            else leverDR = 0;
        }
                
    }//VERTICAL CHAINSAW
    
    //FLOOR OF SPIKES
    if(currentAttack == 2) //currentAttack == 2)
    {
        //Initialize Attack
        if(!attackInitialized)
        {
            //Floor of spikes vars
            spikeEntrance = true;
            spikeEAlarm = 0;
            spikeEDelay = 3; //5
            spikeEPos = 0
            spikeOGX = 60;
            spikeOGY = 320;
            spikeWidth = 20;
            spikeCount = 42;
            
            spikeSlide = false;
            spikeSlideDir = 1;
            spikeSlideAlarm = 0;
            spikeSlideDelay = 2;
            spikeSlidePos = 0;
            
            spikeSlam = false;
            fastSpikeSlam = false;
            fastVRate = .75;
            prevSpikeSlam = false;
            slamPhase = 0;
            slamAlarm = 0;
            slamX1 = 0+60;
            slamX2 = room_width-60;
            slamY1 = -sprite_get_height(spr_yolkChild_slam);
            slamY2 = 160;
            slamHoverY = slamY1+100;
            //slamHoverAlarm = 30;
            //slamHoverTime = slamHoverAlarm;
            slamX = -1;
            slamPlayerDist = 150;
            slamY = slamY1;
            slamVSpeed = 0;
            slamVRate = .25;  //.25
            slamTpAlarm = 0;
            slamTpTime = 15;
            slamAttack = false;
            slamAttackAlarm = 0;
            slamAttackTime = 150;
            
            shockWave = false;
            prevShockWave = false;
            shockWaveStartPos = 0;    
            shockWavePos = 0;
            shockWaveAlarm = 0;
            shockWaveDelay = 2; //2
            
            platformSpawn = false;
            platformX = sprite_get_width(spr_arrowPlatform)/2;
            platformY1 = 170;
            platformY2 = 260;
            //platformSpawnDir = 1;
            platformAlarm = 0;
            platformDelay = 45; //55
            
            platformSpeed = 0;
            platformSpeedCap = 6; //5
            platformRate = 1;
            platformDir = 0;
            platformSpeedAlarm = 0;
            platformSpeedDelay = 20;
            
            spikeLock = false;
            prevSpikeLock = false;
            
            finalSlamAlarm = 30;
            spikeExit = false;
            prevSpikeExit = false;
            
            //Platform Array (Y)
            platArrayPos = 0;
            platArray[0] = 270;
            platArray[1] = 230;
            platArray[2] = 190;
            platArray[3] = 260;
            platArray[4] = 220;
            platArray[5] = 240;
            platArray[6] = 200;
            platArray[7] = 150;
            platArray[8] = 220;
            platArray[9] = 240;
            //platArray[10] = 200;
            //platArray[11] = 150;
            //platArray[12] = 200;
            //platArray[13] = 150;
            //platArray[14] = 200;
            //platArray[15] = 150;
            
            spikeEnd = false;
            attackInitialized = true;
            
            //Create Slam Instance
            slamInst = instance_create(slamX,slamY,obj_yolkBoss_slam)
            
            //Create Array Of Manual Spikes
            for(i = 0;i &lt; spikeCount;i++)
            {
                spikeArray[i] = instance_create(spikeOGX+spikeWidth*i,spikeOGY,obj_steppingSpikes_manual);
                spikeArray[i].image_alpha = 0;
            }
        }
        
        //Final atttack sequence
        if(attackTimer == 150)
        {
            //spikeSlam = true;
            slamAttack = true;
        }
        else if(attackTimer == 350)
        {
            //spikeSlam = true;
            slamAttack = true;
            slamAttackTime = 100;
            slamVRate = .5;
        }
        else if(attackTimer == 580)
        {
            slamAttack = false;
            //platformSpawn = true;
        }
        else if(attackTimer == 660)
        {
            instance_create(round((.7/3)*room_width),260,obj_movingPlatform_boss_deploy);
            instance_create(round((2.3/3)*room_width),260,obj_movingPlatform_boss_deploy);
        }
        else if(attackTimer == 740)
        {
            spikeSlam = true;
            slamX = room_width/2;
            spikeLock = true;
        }
        else if(attackTimer == 890)
        {
            bossDeployed = true;
            bossDX = room_width/2;
        }
        else if(attackTimer == 985)
        {
            armDeployed = true;
        }
        else if(attackTimer == 1030)
        {
            armLaunchLid = true;
        }
        else if(attackTimer == 1130)
        {
            //Move Platforms Opposite Direction Of Player
            if(obj_player.x &gt; room_width/2)
            {
                platformDir = 1;
                leverDR = -leverRAngle;
                //instance_create(0-platformX,260,obj_movingPlatform_boss);
            }
            else 
            {   
                platformDir = -1;
                leverDR = leverRAngle;
                //instance_create(room_width+platformX,260,obj_movingPlatform_boss);               
            }
        }
        else if(attackTimer == 1131)
        {
            platformSpawn = true;
        }
    
        
        //Slam Attack Manager (System)
        if(slamAttack)
        {
            //Manage Alarm
            if(slamAttackAlarm &gt; 0)
            {
                slamAttackAlarm -= 1;
            }
            //Attack
            else
            {
                spikeSlam = true;
                slamAttackAlarm = slamAttackTime;
            }
        }
        
        //Slam Attack (System)
        if(spikeSlam)
        {
            //Initialize Slam
            if(spikeSlam != prevSpikeSlam)
            {
                //Determine Attack Position
                if(slamVRate == .25)//First Attack
                {
                    slamX = obj_player.x;
                }
                else if(slamX == -1)//Near Player
                {
                    //slamX = obj_player.x;
                    slamX = irandom_range(obj_player.x-slamPlayerDist,obj_player.x+slamPlayerDist);
                }
                
                //Clamp SlamX
                if(slamX &lt; slamX1) slamX = slamX1;
                else if(slamX &gt; slamX2) slamX = slamX2;   
                
                //Find Closest Sprite To Slam Inst
                closestSpike = 0;
                spikeDist = 100;
                for(i = 0;i &lt; spikeCount;i++)
                {
                    //Find Closest Spike
                    if(abs(spikeArray[i].x-slamX) &lt; spikeDist)
                    {
                        closestSpike = i;
                        spikeDist = abs(spikeArray[i].x-slamX);
                    }
                }
                
                //Round SlamInst Pos To Closest Spike
                if(slamX != room_width/2)
                {
                    slamX = spikeArray[closestSpike].x+7; 
                }
                
                //Initialize Hovering Vars
                //slamHoverAlarm = slamHoverTime;  
                
                slamPhase = 0;
            }
            
            //Action Delay
            if(slamAlarm &gt; 0)
            {
                slamAlarm--;
            }
            //Hover Down
            else if(slamPhase == 0)
            {                
                //Set Image
                slamInst.imageIndex = 0;
                slamInst.sprite_index = slamInst.slamSprite;
                
                //Fast Slam Attack
                /*if(fastSpikeSlam)
                {
                    slamPhase++
                }*/
                
                //Hovering Down
                if(true)
                {
                    if(slamY+slamVSpeed+slamVRate &lt; slamHoverY)
                    {
                        slamVSpeed += slamVRate;
                        slamY += slamVSpeed;
                    }
                    //Hovered Down
                    else
                    {
                        slamVSpeed = slamVRate*6;
                        slamY = slamHoverY
                        slamAlarm = 20;
                        slamPhase++;
                        
                        //First Spike Slam
                        if(slamVRate == .25)
                        {
                            slamVSpeed = 0;
                        }
                        //Fast Spike Slam
                        else if(fastSpikeSlam)
                        {
                            slamAlarm = 20;
                            slamVSpeed = slamVRate*8;
                        }
                    }                                
                }
            }
            //Follow Player
            /*else if(slamPhase == 1)
            {
                //Hover For A Time
                if(slamHoverAlarm &gt; 0)
                {
                    //Follow Player Horizontally
                    slamX = obj_player.x; 
                    if(slamX &lt; slamX1) slamX = slamX1;
                    else if(slamX &gt; slamX2) slamX = slamX2; 
                    
                    //Deduct Alarm
                    slamHoverAlarm -= 1;
                }                
                //Cease Hovering
                else
                {
                    slamPhase++;
                }
            }*/
            //Drop Down
            else if(slamPhase == 1)
            {
                //Set Image
                slamInst.imageIndex = 1;
                slamInst.sprite_index = slamInst.slamSprite;
                
                //Fast Dropping
                if(slamY+slamVSpeed+fastVRate &lt; slamY2)
                {
                    slamVSpeed += fastVRate;
                    slamY += slamVSpeed;
                }
                //Dropping
                else if(slamY+slamVSpeed+slamVRate &lt; slamY2)
                {
                    slamVSpeed += slamVRate;
                    slamY += slamVSpeed;
                }
                //Dropped
                else
                {
                    //Send Out Spike Shockwave
                    shockWave = true;
                    shockWaveStartPos = closestSpike;
                
                    //Modify Slam Vars
                    slamVSpeed = 0;
                    slamY = slamY2;
                    slamTpAlarm = slamTpTime;
                    slamAlarm = 20;
                    slamPhase++;
                }
            }            
            //Retract Upwards
            else if(slamPhase == 2)
            {
                //Set Image
                slamInst.imageIndex = 0;
                slamInst.sprite_index = -1;
            
                //Normal Ascension
                if(true) //!fastSpikeSlam)
                {
                    //Ascending
                    if(slamY+slamVSpeed-slamVRate &gt; slamY1)
                    {
                        slamVSpeed -= slamVRate;
                        slamY += slamVSpeed;
                    }                
                    //Ascended
                    else
                    {
                        slamVSpeed = 0;
                        slamY = slamY1;
                        slamPhase++;
                    } 
                }
                
                //Fast Ascension
                if(fastSpikeSlam)
                {
                    //Deduct Alarm
                    if(slamTpAlarm &gt; 0)
                    {
                        slamInst.image_xscale = slamTpAlarm/slamTpTime;
                        //slamInst.image_yscale = 1/slamInst.image_xscale;
                        //slamY = slamY1+(slamY2-slamY1)*(slamTpAlarm/slamTpTime);
                        slamInst.image_alpha = slamTpAlarm/slamTpTime;
                        slamTpAlarm -= 1;
                    }
                    //Teleport
                    else 
                    {
                        slamInst.image_xscale = 1;
                        slamInst.image_yscale = 1;
                        slamInst.image_alpha = 1;
                        slamY = slamY1;
                        slamPhase++;
                    }   
                }  
            }
            //End Slam Attack
            else
            {
                slamX = -1;
                spikeSlam = false;  
            }
        }
        prevSpikeSlam = spikeSlam;
        
        //Restart Attack
        /*if(slamAttack &amp;&amp; !spikeSlam)
        {
            spikeSlam = true;
        } */
        
        
        //Controll Slam Instance (SYSTEM)
        slamInst.x = slamX;
        slamInst.y = slamY;    
        
        //Spike Shockwave Attack (SYSTEM)
        if(shockWave)
        {
            //Initialize Shockwave Attack
            if(shockWave != prevShockWave)
            {
                shockWavePos = 0;
                shockWaveAlarm = 0;
            }
            
            //Shockwave Alarm
            if(shockWaveAlarm &gt; 0)
            {
                shockWaveAlarm -= 1;
            }   
            else
            {
                //Manage Shockwave Left
                if(shockWaveStartPos-shockWavePos &gt;= 0)
                {   
                    spikeArray[shockWaveStartPos-shockWavePos].triggered = true;
                }
                //Manage Shockwave Right
                if(shockWaveStartPos+shockWavePos &lt;= spikeCount-1)
                {
                    spikeArray[shockWaveStartPos+shockWavePos].triggered = true;
                }
            
                //End Shockwave Attack
                if(shockWaveStartPos-shockWavePos &lt; 0 &amp;&amp; shockWaveStartPos+shockWavePos &gt; spikeCount-1)
                {
                    shockWave = false;
                }
                
                //Reset Alarm
                shockWavePos++;
                shockWaveAlarm = shockWaveDelay;
            }
        }
        prevShockWave = shockWave;
        
        //Spike Slide Attack (SYSTEM)
        if(spikeSlide)
        {
            //Systematically Attack With All Spikes
            if(spikeSlideAlarm &gt; 0) spikeSlideAlarm--;
            else if(spikeSlidePos &lt; spikeCount)
            {
                //Determine Spike Slide Direction
                if(spikeSlideDir &gt; 0)
                {
                    spikeArray[spikeSlidePos].triggered = true;
                }
                else if(spikeSlideDir &lt; 0)
                {
                    spikeArray[spikeCount-1-spikeSlidePos].triggered = true;
                }
                
                spikeSlideAlarm = spikeSlideDelay;
                spikeSlidePos++;
            }
            
            //End Attack
            if(spikeSlidePos &gt;= spikeCount)
            {
                spikeSlidePos = 0;
                spikeSlide = false;
            }
        }        
        
        //Spike Entrance (SYSTEM)
        if(spikeEntrance)
        {
            //Systematically Summon All Spikes
            if(spikeEAlarm &gt; 0) spikeEAlarm--;
            else if(spikeEPos &lt; spikeCount)
            {
                //spikeArray[spikeEPos].image_alpha = 1;
                spikeArray[spikeEPos].fadeIn = true;
                spikeEAlarm = spikeEDelay;
                spikeEPos++;
            }
            
            //End Entrance 
            if(spikeEPos &gt;= spikeCount)
            {
                spikeEPos = 0;
                spikeEntrance = false;
            }
        }
        
        //Lock and Unlock Spikes
        if(spikeLock != prevSpikeLock)
        {
            for(i = 0;i &lt; spikeCount;i++)
            {
                spikeArray[i].locked = spikeLock;
            }
        }
        prevSpikeLock = spikeLock;
        
        //Platform Spawner (SYSTEM)
        if(platformSpawn &amp;&amp; abs(platformSpeed) &gt;= 4) //abs(platformSpeed) == abs(platformSpeedCap))
        {
            //Countdown Alarm
            if(platformAlarm &gt; 0)
            {
                platformAlarm -= 1;
            }
            //Spawn Platform
            else
            {
                //Create and Modify Platform
                //tvObj = instance_create(platformX,platformY,obj_movingPlatform_boss);
                //tvObj.image_xscale = platformSpawnDir;
                //tvObj.hSpeed *= platformSpawnDir;
                
                //Spawn Platform On Corresponding Side
                //platformY = irandom_range(platformY1,platformY2);
                
                //Platform Spawning Based On Array
                if(platArrayPos &lt; array_length_1d(platArray))
                {
                    platformY = platArray[platArrayPos];
                    platArrayPos++;
                                           
                    //Spawn Platform
                    if(platformDir &gt; 0)
                    {
                        instance_create(0-platformX,platformY,obj_movingPlatform_boss);

                    }
                    else if(platformDir &lt; 0)
                    {
                        instance_create(room_width+platformX,platformY,obj_movingPlatform_boss);
                    }
                }
                
                //Stop Spawning Platforms (and end attack)
                else
                {
                    spikeLock = false;
                    spikeEnd = true;
                }
                
                //Reset Alarm 
                platformAlarm = platformDelay;
            }
        }
        
        //Manipulate Platform Speed (SYSTEM)
        if(platformDir != 0) // &amp;&amp; platformSpeed != platformDir*platformSpeedCap)
        {
            //Countdown Alarm
            if(platformSpeedAlarm &gt; 0)
            {
                platformSpeedAlarm -= 1;
            }
            //Modify Platforms
            else
            {
                //Move Towards
                if(sign(platformSpeed-(platformDir*platformSpeedCap)) == sign(platformSpeed+platformRate*platformDir-(platformDir*platformSpeedCap)))
                {
                    platformSpeed += platformRate*platformDir;
                }            
                //Stop At Specified Speed
                else
                {
                    platformSpeed = platformSpeedCap*platformDir;
                }   
                
                //Reset Alarm
                platformSpeedAlarm = platformSpeedDelay;
            }
        }
        else platformSpeed = 0;
        
        //Set Platform To Platform Speed
        if(instance_exists(obj_movingPlatform))
        {
            //Apply Speed To All Instances
            for(i = 0;i &lt; instance_number(obj_movingPlatform);i++)
            {
                tvObj = instance_find(obj_movingPlatform,i);
                tvObj.hSpeed = platformSpeed;
            }
        }   
        
        //Set All Spikes To Exit
        if(spikeExit != prevSpikeExit)
        {
            //Set All Spikes To New Value
            for(i = 0;i &lt; array_length_1d(spikeArray);i++)
            {
                spikeArray[i].exiting = spikeExit;
            }
        }
        prevSpikeExit = spikeExit;
    
        //End Platform/Spike Attack (SYSTEM)
        if(spikeEnd)
        {
            //Put Away Boss Arm
            if(armAngle+armSpeed-armRate &gt; armAngle1)
            {
                armDeployed = false;
            }
            //Pull Boss Character Off Screen
            else if(bossY != bossY1)
            {
                bossDeployed = false;
            }
            //Delay Final Stomp Attack
            else if(finalSlamAlarm &gt; 0)
            {   
                finalSlamAlarm -= 1;
            }
            //Final Stomp Attack
            else if(!spikeExit)
            {
                spikeSlam = true;
                spikeExit = true;
            }
            //Delete All Attack Instances And End Attack
            else if(!instance_exists(obj_steppingSpikes_manual))
            {
                instance_destroy(slamInst);
                currentAttack = -1;
            }
        }        
    }
    
    
    
    //SWINGING PENDULUM
    if(currentAttack == 3)
    {
        //Initialize Attack Vars
        if(!attackInitialized)
        {
            //Pendulum Variables
            pendLockAlarm = 0;
            pendLockTime = 30;
            pendX = 300;
            pendY = 50;
            pendPrevAngle = -1;
            warnSprite = spr_pendulumWarning;
            warnImg = 0;
            
            //Create Pendulum
            pendInst = instance_create(pendX,pendY,obj_pendulum_super);
            pendInst.depth = depth+.01;
            
            //Create Saw
            sawInst = instance_create(-50,320,obj_saw_boss);
            
            attackInitialized = true;
        }
                       
        //Test Locking Pendulum
        /*if(attackTimer == 50)
        {
            pendInst.locked = true;
        }
        else if(attackTimer == 150)
        {
            pendInst.locked = false;
        }
        else if(attackTimer == 200)
        {
            pendInst.locked = true;
        }
        else if(attackTimer == 275)
        {
            pendInst.locked = false;
        }
        else if(attackTimer == 400)
        {
            tvObject = instance_create(room_width+40,300,obj_bullet)
            tvObject.image_xscale = -1;
        }
        else if(attackTimer == 480)
        {
            tvObject = instance_create(0-40,300,obj_bullet)
            tvObject.image_xscale = 1;
        }*/
        
        sawInst.x ++;
        
        //Have Pendulum Follow Player
        pendX = obj_player.x;        
        
        //Control Pendulum Position (SYSTEM)
        pendInst.x = pendX;
        pendInst.y = pendY;
        
        //Swing Pendulum Back And Forth (SYSTEM)
        if(pendInst.locked &amp;&amp; pendPrevAngle == pendInst.image_angle)
        {
            //Countdown Lock Alarm
            if(pendLockAlarm &gt; 0)
            {
                pendLockAlarm -= 1;
            }
            //Unlock
            else
            {
                pendInst.locked = false;
                obj_player.image_xscale += .01;
            }
        }
        //Relock Pendulum
        else
        {   
            pendLockAlarm = pendLockTime;
            pendInst.locked = true;
        }
        
        //Draw Pendulum Warning (SYSTEM)
        if(pendPrevAngle != pendInst.image_angle)
        {
            warnImg = 0;
        }
        else if(pendInst.locked)
        {
            warnImg = 1;
        }
        pendPrevAngle = pendInst.image_angle;
    }
    
    //BACKGROUND BULLET HELL
    else if(currentAttack == 4)
    {
        //Initialize Attack Variables
        if(!attackInitialized)
        {
            //Background Yolk Vars
            
            
            
            
            attackInitialized = true;
        }
        
        //Manage Attack Events
        if(attackTimer == 1)
        {
            shipDeployed = true;
        }
        else if(attackTimer == 300)
        {
            shipDeployed = false;
        }
    }
}


//Boss Character Position Manager
if(true) //bossX != bossDX)
{        
    //Undeploy Boss
    /*if(bossDeployed)
    {   
        bossDeployed = false;
    }*/
    
    //Manage Boss Movement (While Deployed)
    if(bossY == bossY2 &amp;&amp; bossDeployed)
    {
        //Follow Player
        //bossDX = obj_player.x;
        //bossHSpeed = bossHCap*sign(bossDX-bossX);
    
        //Move Boss Horizontally
        if(sign(bossX-bossDX) == sign(bossX+bossHSpeed-bossDX))
        {
            bossX += bossHSpeed; //*sign(bossDX-bossX); //bossHSpeed;
        }
        else bossX = bossDX;
    }
    
    //Reset Boss Position (While NOT Deployed)
    if(bossX != bossDX &amp;&amp; bossY == bossY1 &amp;&amp; !bossDeployed)
    {
        bossX = bossDX;
    }   
}

//Undeploy Boss
if(!bossDeployed)
{
    //Get Boss Off Screen
    if(bossY+bossVSpeed-bossVRate &gt; bossY1)
    {
        //Increase Boss Undeployment VSpeed
        if(bossVSpeed-bossVRate &gt; -bossVCap)
        {
            bossVSpeed -= bossVRate;
        }
        bossY += bossVSpeed
    }
    else
    {
        bossVSpeed = 0;
        bossY = bossY1;
    }
}
//Deploy Boss
else if(bossDeployed)
{
    //Calculate Boss VSpeed
    if(bossDeployed != prevBossDeployed)
    {    
        //Initialize Tracking Variables
        deployDist = (bossY2-bossY);
        deployPos = 0;
        deployTotalPos = 0;
        
        //Determine VSpeed
        do{
            deployPos++;
            deployTotalPos += bossDeployRate*deployPos;
        }
        until abs(deployTotalPos) &gt;= abs(deployDist);
        
        //show_debug_message(deployTotalPos);
        //show_debug_message(deployDist);
        bossVSpeed = ((deployPos-1)*bossDeployRate)*sign(deployDist); //!-1
        bossY += (deployDist-(deployTotalPos-deployPos*bossDeployRate));
        //show_debug_message(bossVSpeed);
        
        //Set X Position On Deployment (EDGECASE: Xpos and Deployment Bool Can't Be Changed On Same Frame)
        if(bossDeployed) bossX = bossDX;
    }
    
    //Manage Deployment Speeds
    if(sign(bossY-bossY2) == sign(bossY+bossVSpeed-bossY2) &amp;&amp; bossY != bossY2)
    {
        bossY += bossVSpeed;
        bossVSpeed -= bossDeployRate;
    }
    //Cease Deployment
    else
    {
        bossVSpeed = 0;
        bossY = bossY2;
    }
    
    //if(bossVSpeed != 0) show_debug_message(bossVSpeed);
}

//Get Previous Variables
prevBossDeployed = bossDeployed;
prevLeverDeployed = leverDeployed;

//Boss Arm Deployed
if(armDeployed)
{
    //Deploying 
    if(armAngle+armSpeed+armRate &lt; armAngle2)
    {
        armSpeed += armRate;
        armAngle += armSpeed;
        leverDeployed = false;
        armImg = 0;
    }
    //Deployed
    else
    {
        armSpeed = 0;
        armAngle = armAngle2;
        
        //Launch Arm Lid If Fully Deployed
        if(armLaunchLid)
        {
            armImg = 1;
            leverDeployed = true;
            poppedLidInst = instance_create(bossX-90,bossY+117,obj_poppedLid);
            poppedLidInst.drawColor = bossColor;
            armLaunchLid = false;
        }
    }
}

//Boss Arm Undeployed
else if(!armDeployed)
{
    //Undeploying
    if(armAngle+armSpeed-armRate &gt; armAngle1)
    {   
        armSpeed -= armRate;
        armAngle += armSpeed;
        leverDeployed = false;
    }
    //Undeployed
    else 
    {
        armSpeed = 0;
        armAngle = armAngle1;
    }        
}

//Set Arm Scale
armScale = armScale1+(armScale2-armScale1)*((armAngle-armAngle1)/(armAngle2-armAngle1));

//Manage Lever Movements
if(leverR != leverDR)
{
    //Reset Lever Movement Vars
    if(prevLeverDR != leverDR)
    {
        leverRSpeed = 0;
    }
    
    //Move Towards New Rotation
    if(sign(leverR-leverDR) == sign(leverR+leverRSpeed-leverDR))
    {
        leverR += leverRSpeed;
        leverRSpeed += leverRRate*sign(leverDR-leverR);
    }
    else leverR = leverDR;
}

//Set PreviousLeverDR
prevLeverDR = leverDR;

//Manage Ship Deployment
if(shipDeployed)
{
    //Deploy Ship
    if(shipY != shipY2 &amp;&amp; !shipBobbing)
    {
        if(sign(shipY2-shipY) == sign(shipY2-shipY+shipInitialVSpeed*sign(shipY2-shipY)))
        {
            shipY += shipInitialVSpeed*sign(shipY2-shipY);
        }
        else
        {
            shipY = shipY2;
        }
    }
    //Proceed To Bobbing 
    else
    {
        //Initialize Bobbing Vars
        if(!shipBobbing)
        {
            shipBobY = shipY;
            shipVSpeed = shipInitialVSpeed; //shipVRate*25;
            shipBobbing = true;
        }             
    }    
}
else
{
    //Wait For Bobbing To Subside
    if(shipVSpeed == -shipInitialVSpeed)
    {
        //Turn Off Ship Bobbing
        shipBobbing = false;
    
        //Pull Ship Upwards
        if(sign(shipY1-shipY) == sign(shipY1-shipY+shipInitialVSpeed*sign(shipY1-shipY)))
        {
            shipY += shipInitialVSpeed*sign(shipY1-shipY);
        }
        else
        {
            shipY = shipY1;
        }
    }
}

//Bob The Ship
if(shipBobbing)
{
    //Manage VSpeed
    if(shipY &gt; shipBobY)
    {
        shipVSpeed -= shipVRate;
    }
    else
    {
        shipVSpeed += shipVRate;
    }
        
    //Move Ship 
    shipY += shipVSpeed;
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Draw Debugging 
draw_text(40,20,attackTimer);
draw_text(40,40,currentAttack);
draw_text(40,60,bossVSpeed);
draw_text(40,80,bossDeployed);
    
if(currentAttack == 0)
{
    draw_text(40,100,rocketDirCount);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Don't Draw Self
//draw_self();

//Draw Boss Wire
draw_sprite_ext(spr_clawWire,0,round(bossX),round(bossY),1,(bossY-0)/sprite_get_height(spr_clawWire),0,bossColor,1);

//Draw Boss Arm
draw_sprite_ext(spr_yolkChild_plateArm,armImg,round(bossX)-10,round(bossY)+130,armScale,armScale,armAngle,bossColor,1);

//Manage Lever Draw Level
if(leverDeployed != prevLeverDeployed)
{
    leverDrawHeight = 0;
}
//Draw Boss Lever
if(leverDeployed)
{
    //Manage Draw Heights
    if(instance_exists(poppedLidInst))
    {
        //Increase Draw Height
        if(round(poppedLidInst.y) &lt; bossY+leverY-leverDrawHeight)
        {
            leverDrawHeight = (bossY+leverY-round(poppedLidInst.y)); //-(bossY+leverY);   
            leverArmDrawHeight = leverDrawHeight;
            
            //Clamp Lever Base Height         
            if(leverDrawHeight &gt; leverHeight)
            {                
                leverDrawHeight = leverHeight;
            }
            //Clamp Lever Arm Draw Height
            if(leverArmDrawHeight &gt; leverArmHeight)
            {
                leverArmDrawHeight = leverArmHeight
            }
        }
    }
    
    //Draw Lever (NOTE: LEVER-BASE MUST BE AS TALL AS ENTIRE LEVER)   
    draw_sprite_part_ext(spr_lever,0,0,leverHeight-leverDrawHeight,
    sprite_get_width(spr_lever),leverDrawHeight,floor(bossX+leverX-sprite_get_width(spr_lever)/2), //round
    bossY+leverY-leverDrawHeight+(leverHeight-sprite_get_yoffset(spr_lever)),1,1,bossColor,1);

    //Draw Lever Arm (Intro)
    if(leverArmDrawHeight != leverArmHeight)
    {
        draw_sprite_part_ext(spr_leverArm,0,0,leverArmHeight-leverArmDrawHeight,
        sprite_get_width(spr_leverArm),leverArmDrawHeight,floor(bossX+leverX-  //floor or ceil (change accordingly)
        sprite_get_width(spr_leverArm)/2),bossY+leverY-leverArmDrawHeight+
        (sprite_get_height(spr_leverArm)-sprite_get_yoffset(spr_leverArm)),1,1,bossColor,1);
    }
    else //(Functional) 
    {
        draw_sprite_ext(spr_leverArm,0,bossX+leverX+(floor(sprite_get_width(spr_leverArm)/2)+ //floor or ceil (change accordingly)
        (sprite_get_xoffset(spr_leverArm)-sprite_get_width(spr_leverArm))),bossY+leverY,1,1,leverR,bossColor,1);
    }
    
}

//Draw Airship and Tiny Boss
if(true)
{
    //Control ShipX Relative To Camera
    shipXOffSet = shipXOffSet2-(shipXOffSet2-shipXOffSet1)*(view_xview[0]/(0+room_width-view_wview[0]));
    shipX = round(view_xview[0]+shipXOffSet);
    roundShipY = round(shipY);
    
    //Draw Tiny Wire
    draw_sprite_ext(spr_airship_wire,0,shipX,roundShipY+tinyBossY,1,((roundShipY+tinyBossY)-roundShipY)/sprite_get_height(spr_airship_wire),0,bossColor,1);
    
    //Draw Tiny Boss
    draw_sprite_ext(spr_airship_yolkchild,0,shipX,roundShipY+tinyBossY,1,1,0,bossColor,1);
    
    //Draw Ship
    draw_sprite_ext(spr_airship,0,shipX,roundShipY,1,1,0,bossColor,1);
    
    //Draw Wires For Tiny Guns
    draw_sprite_ext(spr_airship_wire,0,shipX+gunXOffSet,roundShipY+tinyBossY+gunYOffSet,-1,((roundShipY+tinyBossY+gunYOffSet)-roundShipY)/sprite_get_height(spr_airship_wire),0,bossColor,1);
    draw_sprite_ext(spr_airship_wire,0,shipX-gunXOffSet,roundShipY+tinyBossY+gunYOffSet,1,((roundShipY+tinyBossY+gunYOffSet)-roundShipY)/sprite_get_height(spr_airship_wire),0,bossColor,1);
    
    //Draw Tiny Guns
    draw_sprite_ext(spr_airship_gun,0,shipX+gunXOffSet,roundShipY+tinyBossY+gunYOffSet,-1,1,0,bossColor,1);
    draw_sprite_ext(spr_airship_gun,0,shipX-gunXOffSet,roundShipY+tinyBossY+gunYOffSet,1,1,0,bossColor,1);
}

//Draw Pendulum Warning
if(currentAttack == 3)
{
    draw_sprite(warnSprite,warnImg,pendX,pendY);
}

//Draw Boss Character
draw_sprite_ext(spr_yolkChild_wink,0,round(bossX),round(bossY),1,1,0,bossColor,1);


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
