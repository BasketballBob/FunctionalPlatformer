<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_yolkChild</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Basic Variables


//Yolk Boss Variables

//Attack Management Vars
currentAttack = -1;
attackRange = 2;
attackInitialized = false;
attackTimer = -1;

//Boss Character Variables
bossDeployed = false;
prevBossDeployed = bossDeployed;
bossDeployRate = .25;
bossX = 400;
bossY = -300;
bossDX = 400;
bossY1 = -300;
bossY2 = 78; //50
bossHSpeed = 1;
bossHCap = 1;
bossVSpeed = 0;
bossVRate = 1;
bossVCap = 6; //Used For Boss Undeployment 
bossColor = make_color_rgb(200,200,200);

//Arm Deployment Vars
armDeployed = false;
armLaunchLid = false;
armImg = 0;
armSpeed = 0;
armRate = .2; //.25
armAngle = -90; //Should equal armAngle1
armAngle1 = -90;
armAngle2 = 0;
armScale = 1;
armScale1 = .1; //.1
armScale2 = 1;
lidX = -90;
lidY = 117;

//Lever Variables (NOTE: To get intro and function leverArms to line up
//you may need to make adjustments in their draw (sorry messy code))
leverDeployed = false;
prevLeverDeployed = false;
leverHeight = sprite_get_height(spr_lever);
leverDrawHeight = 0;
leverArmHeight = sprite_get_height(spr_leverArm);
leverArmDrawHeight = 0;
leverX = -90; 
leverY = 121;
leverR = 0; //R = Rotation
leverDR = 0;
prevLeverDR = 0;
leverRSpeed = 0;
leverRRate = .25;
leverRAngle = 43;






</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>

//Switch Attack
if(currentAttack == -1)
{
    //Determine New  Attack
    //currentAttack = irandom_range(0,attackRange-1);
    currentAttack = 2;
    
    //Reset Attack Timer
    attackTimer = 0;
    
    //Reset Attack Initialization
    attackInitialized = false;
}

//Manage Boss Attacks
if(currentAttack != -1)
{
    //Increment Attack Timer
    attackTimer += 1;
    
    //ROCKET BARRAGE
    if(currentAttack == 0)
    {
        //Initialize Attack 
        if(!attackInitialized)
        {
            //Attack Variables
            rocketFiring = true;
            rocketAlarm = 0;
            rocketTime = 40;
            rocketY1 = 270;
            rocketY2 = 320;
            rocketDist = 25; //(Offset From Edge Of Screen) //50
            rocketHRange = 75;
            rocketDirCount = 0;
            rocketDirCap = 3;
            
            //Cease Initialization
            attackInitialized = true;
        }
        
        //Begin Firing Rockets
        if(attackTimer == 20)
        {
            rocketFiring = true;                      
        } 
        //Stop Firing Rockets
        else if(attackTimer == 450)
        {
            rocketFiring = false;
        }
        
        //END ATTACK
        else if(attackTimer == 525)
        {
            currentAttack = -1;
        }
        
        //Rocket Firing (SYSTEM)
        if(rocketFiring)
        {
            //Rocket Firing Alarm
            if(rocketAlarm &gt; 0) rocketAlarm -= 1;
            //Firing Of Rockets
            else
            {
                //Determine Firing Direction
                tvRandom = irandom_range(0,1);
                
                //Fire To The Right
                if(tvRandom == 0 &amp;&amp; rocketDirCount &lt; rocketDirCap || rocketDirCount &lt;= -rocketDirCap)
                {
                    tvObject = instance_create(view_xview[0]+rocketDist+irandom_range(0,rocketHRange),irandom_range(rocketY1,rocketY2),obj_rocketLauncher_boss)
                    tvObject.image_xscale = 1;
                    rocketDirCount++;
                }              
                //Fire To The Left
                else if(tvRandom == 1 &amp;&amp; rocketDirCount &gt; -rocketDirCap || rocketDirCount &gt;= rocketDirCap)
                {
                    tvObject = instance_create(view_xview[0]+view_wview[0]-rocketDist-irandom_range(0,rocketHRange),irandom_range(rocketY1,rocketY2),obj_rocketLauncher_boss)
                    tvObject.image_xscale = -1;
                    rocketDirCount--;
                }
                
                //Reset RocketDirCount
                if(tvObject.image_xscale == 1 &amp;&amp; tvRandom == 1 || tvObject.image_xscale == -1 &amp;&amp; tvRandom == 0)
                {
                    rocketDirCount = 0;
                }
                
                //Reset Firing Alarm
                rocketAlarm = rocketTime;
            } 
        }                         
    }
    
    //VERTICAL CHAINSAW
    if(currentAttack == 1)
    {
        //Initialize Attack
        if(!attackInitialized)
        {
            //Attack Variables
            sawArrayExists = true;
            sawBorder = -40; //80
            sawX1 = 0+sawBorder;
            sawX2 = room_width-sawBorder;
            sawY1 = -40; //-60
            sawY2 = 30; //300 
            sawCount = 7; //9
            
            sawMoveSpeed = 1;
            sawHSpeed = 0; //(One Val For ALL Saws)
            sawHCap = 3;
            sawHRate = .25;
            sawHRateMod = 1;
            sawHRateAlarm = 0;
            sawHRateTime = 10;
            sawHDir = 0;
            sawBobbing = false;
            stopBobbing = false;
            dropSaws = true;
            pullSaws = false;
            sawGrav = .5;
            sawVCap = 5;
            sawOGY = room_height/2;
            
            //Generate Array Of BuzzSaws
            for(i = 0;i &lt; sawCount;i++) 
            {
                sawArray[i] = instance_create(sawX1+i*((sawX2-sawX1)/(sawCount)),sawY1,obj_saw_boss); //sawCount-1 (EDGECASE: saws spawning in eachother)
                sawVSpeedArray[i] = 0; //Starting VSpeed Value
            }
            
            //Cease Initialization
            attackInitialized = true;
        }
                
        
        //Deploy Boss
        if(attackTimer == 20)
        {
            bossDeployed = true;
            bossDX = room_width/2;
        }
        //Deploy Boss Arm/Lever
        else if(attackTimer == 90)
        {
            armDeployed = true;
        }
        else if(attackTimer == 140)
        {
            armLaunchLid = true;
        }
        //Begin Saw Bobbing
        else if(attackTimer == 210)
        {
            sawBobbing = true;
        }
        //Move Saws In Various Directions
        else if(attackTimer == 275) sawHDir = 1;
        else if(attackTimer == 475) sawHDir = -1;
        
        //END ATTACK
        else if(attackTimer == 715)
        {
            //sawBobbing = false;
            stopBobbing = true;
            //pullSaws = true;
            sawHDir = 0;     
        }
        else if(attackTimer == 740)
        {
            pullSaws = true;
            armDeployed = false;
        }
        else if(attackTimer == 850)
        {
            bossDeployed = false;
        }
        else if(attackTimer == 940)
        {
            currentAttack = -1;
            obj_player.image_xscale = 15;
        }
        
        
        //Begin Bobbing/Horizontal Movement
        /*else if(attackTimer == 150) 
        {
            sawBobbing = true;
            //sawHDir = 1;
            armDeployed = true;
        }
        //TEST ATTACK EVENTS
        else if(attackTimer == 200)
        {
            armLaunchLid = true;
        }
        else if(attackTimer == 300)
        {
            leverDR = -leverRAngle;
        }
        else if(attackTimer == 320)
        {
            sawHDir = 1;
        }
        else if(attackTimer == 575)
        {
            leverDR = leverRAngle;
            sawHDir = -1;
        }
        
        //Turnaround 
        else if(attackTimer == 700)
        {            
            //armDeployed = false;
        }*/                    
        
        //Move Saws Downwards ENTRANCE (SYSTEM)
        if(dropSaws &amp;&amp; !sawBobbing &amp;&amp; sawArrayExists)
        {
            //Move Sawblades
            for(i = 0;i &lt; sawCount;i++)
            {
                //Move Towards Position
                if(sawArray[i].y &lt; sawY2)
                {
                    sawArray[i].y += sawMoveSpeed;
                }
                //Lock At Position
                else
                {
                    sawArray[i].y = sawY2;   
                    dropSaws = false;                 
                }
            }
        }
        //Move Sawblades Upwards EXIT (SYSTEM)
        else if(pullSaws &amp;&amp; !sawBobbing &amp;&amp; sawArrayExists)
        {
            //Move Sawblades
            for(i = 0;i &lt; sawCount;i++)
            {
                //Move Towards Position
                if(sawArray[i].y &gt; sawY1)
                {
                    sawArray[i].y -= sawMoveSpeed;
                }
                //Lock At Position
                else
                {
                    //Delete Saw Array (WILL DELETE ALL SAWS WHEN FIRST SAW IS CALLED TO BE DELETED)
                    for(i = 0;i &lt; sawCount;i++)
                    {
                        instance_destroy(sawArray[i]);
                    }
                    
                    sawArrayExists = false;
                    pullSaws = false;
                    break;                 
                }
            }
        }     
        
        //Manage Sawblade Bobbing (SYSTEM)
        if(sawBobbing &amp;&amp; sawArrayExists)
        {
            for(i = 0;i &lt; sawCount;i++)
            {
                //Gravitate Upwards
                if(sawArray[i].y &gt; sawOGY)
                {
                    sawVSpeedArray[i] -= sawGrav;                   
                }
                //Gravitate Downwards
                else
                {
                    sawVSpeedArray[i] += sawGrav;
                }
                
                //Actually Move Saw Position (vertically)
                sawArray[i].y += sawVSpeedArray[i];       
                
                //Stop Bobbing
                if(stopBobbing)
                {
                    //Stop Once Top Of Screen Is Hit
                    if(sawVSpeedArray[i] == 0 &amp;&amp; sawArray[i].y &lt; room_height/2)
                    {
                        sawBobbing = false;
                        stopBobbing = false;
                    }
                }                                                
            }
         }
         
        //Manage Sawblade Horizontal Movement (SYSTEM)
        if(sawHDir == 1 &amp;&amp; sawArrayExists || sawHDir == -1 &amp;&amp; sawArrayExists || sawHDir = 0 &amp;&amp; sawArrayExists)
        {
            //Determine Saw HRate Modifier (Makes turning around faster)
            if(sign(sawHSpeed) == -sign(sawHDir))
            {
                sawHRateMod = 2;
            }
            else sawHRateMode = 1;
            
            //Manage HRate Alarm
            if(sawHRateAlarm &gt; 0) 
            {
                sawHRateAlarm -= 1;
            }
            //Saw Dir 1
            else if(sawHDir == 1 &amp;&amp; sawHSpeed+sawHRate*sawHRateMod*sawHDir &lt; sawHCap*sawHDir)
            {
                sawHSpeed += sawHRate*sawHRateMod*sawHDir;
                sawHRateAlarm = sawHRateTime;
            }
            else if(sawHDir == 1)
            {
                sawHSpeed = sawHCap*sawHDir;
                sawHRateAlarm = sawHRateTime;
            }
            //Saw Dir -1
            else if(sawHDir == -1 &amp;&amp; sawHSpeed+sawHRate*sawHRateMod*sawHDir &gt; sawHCap*sawHDir)
            {
                sawHSpeed += sawHRate*sawHRateMod*sawHDir;
                sawHRateAlarm = sawHRateTime;
            }
            else if(sawHDir == -1)
            {
                sawHSpeed = sawHCap*sawHDir;
                sawHRateAlarm = sawHRateTime;
            }
            
            //Slow To A Stop
            else if(sawHDir == 0)
            {
                sawHSpeed -= sawHRate*sign(sawHSpeed);
                sawHRateAlarm = sawHRateTime;
            }
            
            //Modify All Saws Accordingly
            for(i = 0;i &lt; sawCount;i++)
            {          
                //Move Saws 
                sawArray[i].x += sawHSpeed;
                  
                //Have Saws Loop Past Boundaries
                if(sawArray[i].x &lt; sawX1)
                {
                    sawArray[i].x = sawX2;
                }
                else if(sawArray[i].x &gt; sawX2)
                {
                    sawArray[i].x = sawX1;
                }
            }                       
            
            //Manage Lever Dir
            if(sawHDir == 1) leverDR = -leverRAngle;
            else if(sawHDir == -1) leverDR = leverRAngle;
            else leverDR = 0;
        }
                
    }//VERTICAL CHAINSAW
    
    //FLOOR OF SPIKES
    if(currentAttack == 2) //currentAttack == 2)
    {
        //Initialize Attack
        if(!attackInitialized)
        {
            //Floor of spikes vars
            spikeEntrance = true;
            spikeEAlarm = 0;
            spikeEDelay = 3; //5
            spikeEPos = 0
            spikeOGX = 60;
            spikeOGY = 320;
            spikeWidth = 20;
            spikeCount = 42;
            
            spikeSlide = false;
            spikeSlideDir = 1;
            spikeSlideAlarm = 0;
            spikeSlideDelay = 2;
            spikeSlidePos = 0;
            
            spikeSlam = false;
            prevSpikeSlam = false;
            slamPhase = 0;
            slamAlarm = 0;
            slamX1 = 0+60;
            slamX2 = room_width-60;
            slamY1 = -sprite_get_height(spr_yolkChild_slam);
            slamY2 = 180;
            slamHoverY = slamY1+100;
            //slamHoverAlarm = 30;
            //slamHoverTime = slamHoverAlarm;
            slamX = 0;
            slamY = slamY1;
            slamVSpeed = 0;
            slamVRate = .25;   
            
            shockWave = false;
            prevShockWave = false;
            shockWaveStartPos = 0;    
            shockWavePos = 0;
            shockWaveAlarm = 0;
            shockWaveDelay = 2;    
            
            attackInitialized = true;
            
            //Create Slam Instance
            slamInst = instance_create(slamX,slamY,obj_yolkBoss_slam)
            
            //Create Array Of Manual Spikes
            for(i = 0;i &lt; spikeCount;i++)
            {
                spikeArray[i] = instance_create(spikeOGX+spikeWidth*i,spikeOGY,obj_steppingSpikes_manual);
                spikeArray[i].image_alpha = 0;
            }
        }
        
        //Spike Slide Attack 0
        if(attackTimer == 150)
        {
            //spikeSlide = true;
            //spikeSlideDir = 1;
            spikeSlam = true;
        }
        else if(attackTimer == 550)
        {
            //spikeSlide = true;
            //spikeSlideDir = -1;
            spikeSlam = true;
        }
        
        
        //Slam Attack (System)
        if(spikeSlam)
        {
            //Initialize Slam
            if(spikeSlam != prevSpikeSlam)
            {
                //Determine Attack Position
                slamX = obj_player.x;
                if(slamX &lt; slamX1) slamX = slamX1;
                else if(slamX &gt; slamX2) slamX = slamX2;   
                
                //Find Closest Sprite To Slam Inst
                closestSpike = 0;
                spikeDist = 100;
                for(i = 0;i &lt; spikeCount;i++)
                {
                    //Find Closest Spike
                    if(abs(spikeArray[i].x-slamX) &lt; spikeDist)
                    {
                        closestSpike = i;
                        spikeDist = abs(spikeArray[i].x-slamX);
                    }
                }
                
                //Initialize Hovering Vars
                //slamHoverAlarm = slamHoverTime;  
                
                slamPhase = 0;
            }
            
            //Action Delay
            if(slamAlarm &gt; 0)
            {
                slamAlarm--;
            }
            //Hover Down
            else if(slamPhase == 0)
            {                
                //Hovering Down
                if(slamY+slamVSpeed+slamVRate &lt; slamHoverY)
                {
                    slamVSpeed += slamVRate;
                    slamY += slamVSpeed;
                }
                //Hovered Down
                else
                {
                    slamVSpeed = 0;
                    slamY = slamHoverY
                    slamAlarm = 20;
                    slamPhase++;
                }
                                
            }
            //Follow Player
            /*else if(slamPhase == 1)
            {
                //Hover For A Time
                if(slamHoverAlarm &gt; 0)
                {
                    //Follow Player Horizontally
                    slamX = obj_player.x; 
                    if(slamX &lt; slamX1) slamX = slamX1;
                    else if(slamX &gt; slamX2) slamX = slamX2; 
                    
                    //Deduct Alarm
                    slamHoverAlarm -= 1;
                }                
                //Cease Hovering
                else
                {
                    slamPhase++;
                }
            }*/
            //Drop Down
            else if(slamPhase == 1)
            {
                //Dropping
                if(slamY+slamVSpeed+slamVRate &lt; slamY2)
                {
                    slamVSpeed += slamVRate;
                    slamY += slamVSpeed;
                }
                //Dropped
                else
                {
                    //Send Out Spike Shockwave
                    shockWave = true;
                    shockWaveStartPos = closestSpike;
                
                    //Modify Slam Vars
                    slamVSpeed = 0;
                    slamY = slamY2;
                    slamAlarm = 30;
                    slamPhase++;
                }
            }            
            //Retract Upwards
            else if(slamPhase == 2)
            {
                //Ascending
                if(slamY+slamVSpeed-slamVRate &gt; slamY1)
                {
                    slamVSpeed -= slamVRate;
                    slamY += slamVSpeed;
                }                
                //Ascended
                else
                {
                    slamVSpeed = 0;
                    slamY = slamY1;
                    slamPhase++;
                }   
            }
            //End Slam Attack
            else
            {
                spikeSlam = false;            
            }
        }
        prevSpikeSlam = spikeSlam;
        
        //Controll Slam Instance (SYSTEM)
        slamInst.x = slamX;
        slamInst.y = slamY;    
        
        //Spike Shockwave Attack (SYSTEM)
        if(shockWave)
        {
            //Initialize Shockwave Attack
            if(shockWave != prevShockWave)
            {
                shockWavePos = 0;
                shockWaveAlarm = 0;
            }
            
            //Shockwave Alarm
            if(shockWaveAlarm &gt; 0)
            {
                shockWaveAlarm -= 1;
            }   
            else
            {
                //Manage Shockwave Left
                if(shockWaveStartPos-shockWavePos &gt;= 0)
                {   
                    spikeArray[shockWaveStartPos-shockWavePos].triggered = true;
                }
                //Manage Shockwave Right
                if(shockWaveStartPos+shockWavePos &lt;= spikeCount-1)
                {
                    spikeArray[shockWaveStartPos+shockWavePos].triggered = true;
                }
            
                //End Shockwave Attack
                if(shockWaveStartPos-shockWavePos &lt; 0 &amp;&amp; shockWaveStartPos+shockWavePos &gt; spikeCount-1)
                {
                    shockWave = false;
                }
                
                //Reset Alarm
                shockWavePos++;
                shockWaveAlarm = shockWaveDelay;
            }
        }
        prevShockWave = shockWave;
        
        //Spike Slide Attack (SYSTEM)
        if(spikeSlide)
        {
            //Systematically Attack With All Spikes
            if(spikeSlideAlarm &gt; 0) spikeSlideAlarm--;
            else if(spikeSlidePos &lt; spikeCount)
            {
                //Determine Spike Slide Direction
                if(spikeSlideDir &gt; 0)
                {
                    spikeArray[spikeSlidePos].triggered = true;
                }
                else if(spikeSlideDir &lt; 0)
                {
                    spikeArray[spikeCount-1-spikeSlidePos].triggered = true;
                }
                
                spikeSlideAlarm = spikeSlideDelay;
                spikeSlidePos++;
            }
            
            //End Attack
            if(spikeSlidePos &gt;= spikeCount)
            {
                spikeSlidePos = 0;
                spikeSlide = false;
            }
        }        
        
        //Spike Entrance (SYSTEM)
        if(spikeEntrance)
        {
            //Systematically Summon All Spikes
            if(spikeEAlarm &gt; 0) spikeEAlarm--;
            else if(spikeEPos &lt; spikeCount)
            {
                //spikeArray[spikeEPos].image_alpha = 1;
                spikeArray[spikeEPos].fadeIn = true;
                spikeEAlarm = spikeEDelay;
                spikeEPos++;
            }
            
            //End Entrance 
            if(spikeEPos &gt;= spikeCount)
            {
                spikeEPos = 0;
                spikeEntrance = false;
            }
        }
    }
    
    //SWINGING PENDULUM
    if(currentAttack == 3)
    {
        //Initialize Attack Vars
        if(!attackInitialized)
        {
            //Pendulum Variables
            pendLockAlarm = 0;
            pendLockTime = 30;
            pendX = 300;
            pendY = 50;
            pendPrevAngle = -1;
            warnSprite = spr_pendulumWarning;
            warnImg = 0;
            
            //Create Pendulum
            pendInst = instance_create(pendX,pendY,obj_pendulum_super);
            pendInst.depth = depth+.01;
            
            //Create Saw
            sawInst = instance_create(-50,320,obj_saw_boss);
            
            attackInitialized = true;
        }
                       
        //Test Locking Pendulum
        /*if(attackTimer == 50)
        {
            pendInst.locked = true;
        }
        else if(attackTimer == 150)
        {
            pendInst.locked = false;
        }
        else if(attackTimer == 200)
        {
            pendInst.locked = true;
        }
        else if(attackTimer == 275)
        {
            pendInst.locked = false;
        }
        else if(attackTimer == 400)
        {
            tvObject = instance_create(room_width+40,300,obj_bullet)
            tvObject.image_xscale = -1;
        }
        else if(attackTimer == 480)
        {
            tvObject = instance_create(0-40,300,obj_bullet)
            tvObject.image_xscale = 1;
        }*/
        
        sawInst.x ++;
        
        //Have Pendulum Follow Player
        pendX = obj_player.x;        
        
        //Control Pendulum Position (SYSTEM)
        pendInst.x = pendX;
        pendInst.y = pendY;
        
        //Swing Pendulum Back And Forth (SYSTEM)
        if(pendInst.locked &amp;&amp; pendPrevAngle == pendInst.image_angle)
        {
            //Countdown Lock Alarm
            if(pendLockAlarm &gt; 0)
            {
                pendLockAlarm -= 1;
            }
            //Unlock
            else
            {
                pendInst.locked = false;
                obj_player.image_xscale += .01;
            }
        }
        //Relock Pendulum
        else
        {   
            pendLockAlarm = pendLockTime;
            pendInst.locked = true;
        }
        
        //Draw Pendulum Warning (SYSTEM)
        if(pendPrevAngle != pendInst.image_angle)
        {
            warnImg = 0;
        }
        else if(pendInst.locked)
        {
            warnImg = 1;
        }
        pendPrevAngle = pendInst.image_angle;
    }
    
    //BASKETBALL RAIN
}


//Boss Character Position Manager
if(true) //bossX != bossDX)
{        
    //Undeploy Boss
    /*if(bossDeployed)
    {   
        bossDeployed = false;
    }*/
    
    //Manage Boss Movement (While Deployed)
    if(bossY == bossY2 &amp;&amp; bossDeployed)
    {
        //Follow Player
        //bossDX = obj_player.x;
        //bossHSpeed = bossHCap*sign(bossDX-bossX);
    
        //Move Boss Horizontally
        if(sign(bossX-bossDX) == sign(bossX+bossHSpeed-bossDX))
        {
            bossX += bossHSpeed; //*sign(bossDX-bossX); //bossHSpeed;
        }
        else bossX = bossDX;
    }
    
    //Reset Boss Position (While NOT Deployed)
    if(bossX != bossDX &amp;&amp; bossY == bossY1 &amp;&amp; !bossDeployed)
    {
        bossX = bossDX;
    }   
}

//Undeploy Boss
if(!bossDeployed)
{
    //Get Boss Off Screen
    if(bossY+bossVSpeed-bossVRate &gt; bossY1)
    {
        //Increase Boss Undeployment VSpeed
        if(bossVSpeed-bossVRate &gt; -bossVCap)
        {
            bossVSpeed -= bossVRate;
        }
        bossY += bossVSpeed
    }
    else
    {
        bossVSpeed = 0;
        bossY = bossY1;
    }
}
//Deploy Boss
else if(bossDeployed)
{
    //Calculate Boss VSpeed
    if(bossDeployed != prevBossDeployed)
    {    
        //Initialize Tracking Variables
        deployDist = (bossY2-bossY);
        deployPos = 0;
        deployTotalPos = 0;
        
        //Determine VSpeed
        do{
            deployPos++;
            deployTotalPos += bossDeployRate*deployPos;
        }
        until abs(deployTotalPos) &gt;= abs(deployDist);
        
        //show_debug_message(deployTotalPos);
        //show_debug_message(deployDist);
        bossVSpeed = ((deployPos-1)*bossDeployRate)*sign(deployDist); //!-1
        bossY += (deployDist-(deployTotalPos-deployPos*bossDeployRate));
        //show_debug_message(bossVSpeed);
        
        //Set X Position On Deployment (EDGECASE: Xpos and Deployment Bool Can't Be Changed On Same Frame)
        if(bossDeployed) bossX = bossDX;
    }
    
    //Manage Deployment Speeds
    if(sign(bossY-bossY2) == sign(bossY+bossVSpeed-bossY2) &amp;&amp; bossY != bossY2)
    {
        bossY += bossVSpeed;
        bossVSpeed -= bossDeployRate;
    }
    //Cease Deployment
    else
    {
        bossVSpeed = 0;
        bossY = bossY2;
    }
    
    //if(bossVSpeed != 0) show_debug_message(bossVSpeed);
}

//Get Previous Variables
prevBossDeployed = bossDeployed;
prevLeverDeployed = leverDeployed;

//Boss Arm Deployed
if(armDeployed)
{
    //Deploying 
    if(armAngle+armSpeed+armRate &lt; armAngle2)
    {
        armSpeed += armRate;
        armAngle += armSpeed;
        leverDeployed = false;
        armImg = 0;
    }
    //Deployed
    else
    {
        armSpeed = 0;
        armAngle = armAngle2;
        
        //Launch Arm Lid If Fully Deployed
        if(armLaunchLid)
        {
            armImg = 1;
            leverDeployed = true;
            poppedLidInst = instance_create(bossX-90,bossY+117,obj_poppedLid);
            poppedLidInst.drawColor = bossColor;
            armLaunchLid = false;
        }
    }
}

//Boss Arm Undeployed
else if(!armDeployed)
{
    //Undeploying
    if(armAngle+armSpeed-armRate &gt; armAngle1)
    {   
        armSpeed -= armRate;
        armAngle += armSpeed;
        leverDeployed = false;
    }
    //Undeployed
    else 
    {
        armSpeed = 0;
        armAngle = armAngle1;
    }        
}

//Set Arm Scale
armScale = armScale1+(armScale2-armScale1)*((armAngle-armAngle1)/(armAngle2-armAngle1));

//Manage Lever Movements
if(leverR != leverDR)
{
    //Reset Lever Movement Vars
    if(prevLeverDR != leverDR)
    {
        leverRSpeed = 0;
    }
    
    //Move Towards New Rotation
    if(sign(leverR-leverDR) == sign(leverR+leverRSpeed-leverDR))
    {
        leverR += leverRSpeed;
        leverRSpeed += leverRRate*sign(leverDR-leverR);
    }
    else leverR = leverDR;
}

//Set PreviousLeverDR
prevLeverDR = leverDR;




</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Draw Debugging 
draw_text(40,20,attackTimer);
draw_text(40,40,currentAttack);
draw_text(40,60,bossVSpeed);
draw_text(40,80,bossDeployed);
    
if(currentAttack == 0)
{
    draw_text(40,100,rocketDirCount);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Don't Draw Self
//draw_self();

//Draw Boss Wire
draw_sprite_ext(spr_clawWire,0,round(bossX),round(bossY),1,(bossY-0)/sprite_get_height(spr_clawWire),0,bossColor,1);

//Draw Boss Arm
draw_sprite_ext(spr_yolkChild_plateArm,armImg,round(bossX)-10,round(bossY)+130,armScale,armScale,armAngle,bossColor,1);

//Manage Lever Draw Level
if(leverDeployed != prevLeverDeployed)
{
    leverDrawHeight = 0;
}
//Draw Boss Lever
if(leverDeployed)
{
    //Manage Draw Heights
    if(instance_exists(poppedLidInst))
    {
        //Increase Draw Height
        if(round(poppedLidInst.y) &lt; bossY+leverY-leverDrawHeight)
        {
            leverDrawHeight = (bossY+leverY-round(poppedLidInst.y)); //-(bossY+leverY);   
            leverArmDrawHeight = leverDrawHeight;
            
            //Clamp Lever Base Height         
            if(leverDrawHeight &gt; leverHeight)
            {                
                leverDrawHeight = leverHeight;
            }
            //Clamp Lever Arm Draw Height
            if(leverArmDrawHeight &gt; leverArmHeight)
            {
                leverArmDrawHeight = leverArmHeight
            }
        }
    }
    
    //Draw Lever (NOTE: LEVER-BASE MUST BE AS TALL AS ENTIRE LEVER)   
    draw_sprite_part_ext(spr_lever,0,0,leverHeight-leverDrawHeight,
    sprite_get_width(spr_lever),leverDrawHeight,floor(bossX+leverX-sprite_get_width(spr_lever)/2), //round
    bossY+leverY-leverDrawHeight+(leverHeight-sprite_get_yoffset(spr_lever)),1,1,bossColor,1);

    //Draw Lever Arm (Intro)
    if(leverArmDrawHeight != leverArmHeight)
    {
        draw_sprite_part_ext(spr_leverArm,0,0,leverArmHeight-leverArmDrawHeight,
        sprite_get_width(spr_leverArm),leverArmDrawHeight,floor(bossX+leverX-  //floor or ceil (change accordingly)
        sprite_get_width(spr_leverArm)/2),bossY+leverY-leverArmDrawHeight+
        (sprite_get_height(spr_leverArm)-sprite_get_yoffset(spr_leverArm)),1,1,bossColor,1);
    }
    else //(Functional) 
    {
        draw_sprite_ext(spr_leverArm,0,bossX+leverX+(floor(sprite_get_width(spr_leverArm)/2)+ //floor or ceil (change accordingly)
        (sprite_get_xoffset(spr_leverArm)-sprite_get_width(spr_leverArm))),bossY+leverY,1,1,leverR,bossColor,1);
    }
    
}

//Draw Pendulum Warning
if(currentAttack == 3)
{
    draw_sprite(warnSprite,warnImg,pendX,pendY);
}

//Draw Boss Character
draw_sprite_ext(spr_yolkChild_wink,0,round(bossX),round(bossY),1,1,0,bossColor,1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
